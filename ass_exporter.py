"""ASS字幕ファイル出力ロジック."""

from __future__ import annotations

import math
from collections.abc import Callable
from pathlib import Path

import cv2
import numpy as np

from ascii_core import AsciiParams, apply_mask_to_ascii_lines, frame_to_ascii


ASS_HEADER = """[Script Info]
; Script generated by asscii_app.py
Title: ASCII Export
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: {play_res_x}
PlayResY: {play_res_y}

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,{fontname},15,&H00F5F5F5,&H000000FF,&H00101010,&H80101010,0,0,0,0,100,100,0,0,1,2,0,5,20,20,20,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
"""


def sec_to_ass_time(t: float) -> str:
    if t < 0:
        t = 0
    h = int(t // 3600)
    t -= h * 3600
    m = int(t // 60)
    t -= m * 60
    s = int(t)
    cs = int(round((t - s) * 100))
    if cs == 100:
        s += 1
        cs = 0
    return f"{h}:{m:02d}:{s:02d}.{cs:02d}"


WORD_JOINER = "\u2060"


def escape_ass_text(s: str) -> str:
    result: list[str] = []

    for ch in s:
        if ch == "\n":
            result.append(f"\\\\{WORD_JOINER}n")
            continue
        if ch == " ":
            result.append("\\h")
            continue
        if ch == "\\":
            result.append(f"\\\\{WORD_JOINER}")
            continue
        if ch in {"{", "}"}:
            result.append("\\" + ch)
        else:
            result.append(ch)
    return "".join(result)


def lines_to_ass_text(lines: list[str]) -> str:
    return "\\N".join(escape_ass_text(line) for line in lines)


def export_ass(
    video_path: Path,
    out_path: Path,
    params: AsciiParams,
    start_sec: float,
    dur_sec: float | None,
    pos_x: float,
    pos_y: float,
    fontname: str,
    fontsize: int,
    play_res_x: int,
    play_res_y: int,
    mask_lookup: Callable[[int], np.ndarray | None] | None = None,
) -> None:
    cap = cv2.VideoCapture(str(video_path))
    if not cap.isOpened():
        raise RuntimeError("Could not open video for export.")

    fps = max(params.fps, 0.1)
    dt = 1.0 / fps
    target_frames: int | None = None
    if dur_sec is not None:
        target_frames = int(math.ceil(max(dur_sec, 0.0) / dt))

    header = ASS_HEADER.format(
        play_res_x=play_res_x,
        play_res_y=play_res_y,
        fontname=fontname,
    )

    with open(out_path, "w", encoding="utf-8") as f:
        f.write(header)

        i = 0
        while True:
            if target_frames is not None and i >= target_frames:
                break
            t0 = start_sec + i * dt
            t1 = start_sec + (i + 1) * dt

            cap.set(cv2.CAP_PROP_POS_MSEC, t0 * 1000.0)
            ok, frame = cap.read()
            if not ok:
                break
            frame_idx = None
            try:
                pos = cap.get(cv2.CAP_PROP_POS_FRAMES)
            except Exception:
                pos = None
            if pos is not None and not math.isnan(float(pos)):
                frame_idx = max(0, int(pos) - 1)

            gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
            lines = frame_to_ascii(gray, params)
            if mask_lookup is not None and frame_idx is not None:
                mask = mask_lookup(frame_idx)
                if mask is not None and mask.shape == (params.rows, params.cols):
                    lines = apply_mask_to_ascii_lines(lines, mask)
            txt = lines_to_ass_text(lines)

            fs_value = max(1, int(round(fontsize)))
            ass_line = (
                f"Dialogue: 0,{sec_to_ass_time(t0)},{sec_to_ass_time(t1)},"
                f"Default,,0,0,0,,{{\\an5\\fs{fs_value}\\pos({pos_x:.3f},{pos_y:.3f})}}{txt}\n"
            )
            f.write(ass_line)
            i += 1

    cap.release()
